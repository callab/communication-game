# Two Scenarios for Making Changes
## I Want to Add A New Resource
Since a player's inventory is tracked on both the client and the server, you
will have to update code on both sides of the network divide.

On the server side, look first at the `Game` class in the `/lib` directory. It
has a method named `asJSON()`. This method returns a JavaScript object that
eventually gets serialized to a string that gets sent to the client. This is
all the information the server sends the client, which is why this method is a
good place to starting thinking about how to implement new functionality.

We can see that there is nothing about inventories or resources per se, but it
looks like all the `Client`  objects get serialized and sent down to the client
too. If we look at the `Client` class, we can see that on the server side the
inventory is stored here. We can add an additional attribute to the `Inventory`
class and update the code in the `asJSON()` method of that class so that the
new resource gets sent down to the client also.

On the client side, we will have to make a corresponding change. We need to
update the client's count of the new resource whenever the server sends an
update. This update process begins in the `updateAuthoritative()` method of
both the `MapScene` and the `HudScene`. In this case we want the `HudScene`,
since it is responsible for updating the resource UI in the top left of the
screen. We can use this scene to add a new icon and counter for the new
resource, and update that counter when the server sends a response.

What we have done so far syncs up the client and server so that they are
passing information back and forth. We will still need to add logic that
increments the given resource whenever it gets found / dug up. See the
`handleFinishedDig()` method in `lib/game.js` for an example. You will also
have to make sure to add your resource to the tileset generated by
`server-maps/process.js`.

## I Want to Add Autocomplete
The client can handle this entirely on its own. The server doesn't have to be
involved. This is always good news, because it means that everything will be
simpler!

The client asks for a list of all the allowed words at the very beginning of
the game. This list is stored on the global `window` object and available
throughout the client-side program.

The `MessageUI` class is responsible for drawing the chat window for players.
It displays messages that have been stored in the `MessageLog` class. The
`MessageUI` class also listens for new messages on an HTML input element (the
text entry bar). Right now the class only listens for someone hitting the
"enter" key, but we could update this to listen for whenever the input is
changed and then try to suggest the next word to the user.

Unlike most of the client-side code, the `MessageUI` class doesn't use the
Phaser game engine to draw things to the screen. The `MessageUI` class relies
on the browser's native DOM manipulation APIs instead. Check the Mozilla
Developer Network for excellent documentation on these APIs.

In order to actually determine what word to suggest to the user, it will
probably be best to use a third-party library. In order to install a
third-party dependency in the project, make sure to run `yarn install
my-new-library`. This adds the library as an explicit dependency in
`package.json` and makes it available in client-side (and server-side!) code.
